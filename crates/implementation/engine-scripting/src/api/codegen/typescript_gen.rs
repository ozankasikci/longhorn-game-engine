//! TypeScript definition generator for the API registry

use crate::api::registry::{ApiRegistry, NamespaceDescriptor, ClassDescriptor, PropertyDescriptor, MethodBinding};
use std::sync::Arc;

/// Generator for TypeScript definition files
pub struct TypeScriptGenerator {
    registry: Arc<ApiRegistry>,
}

impl TypeScriptGenerator {
    pub fn new(registry: Arc<ApiRegistry>) -> Self {
        Self { registry }
    }

    /// Generate complete TypeScript definitions for all registered APIs
    pub fn generate_definitions(&self) -> String {
        let mut output = String::new();
        
        output.push_str("// Auto-generated TypeScript definitions for Longhorn Engine API\n");
        output.push_str("// Do not edit this file manually\n\n");

        // Generate namespace declarations
        for (namespace_name, descriptor) in self.registry.get_namespaces() {
            output.push_str(&self.generate_namespace(namespace_name, descriptor));
            output.push('\n');
        }

        output
    }

    /// Generate a single namespace declaration
    fn generate_namespace(&self, name: &str, descriptor: &NamespaceDescriptor) -> String {
        let mut output = String::new();
        
        if !descriptor.documentation.is_empty() {
            output.push_str(&format!("/**\n * {}\n */\n", descriptor.documentation));
        }

        output.push_str(&format!("declare namespace {} {{\n", name));

        // Generate methods
        for method_name in &descriptor.methods {
            if let Some(method_binding) = self.registry.get_method(name, method_name) {
                output.push_str(&self.generate_method_signature(method_binding));
            }
        }

        // Generate classes
        for class in &descriptor.classes {
            output.push_str(&self.generate_class(class));
        }

        output.push_str("}\n");
        output
    }

    /// Generate a method signature
    fn generate_method_signature(&self, binding: &MethodBinding) -> String {
        let params = binding.parameter_types
            .iter()
            .enumerate()
            .map(|(i, param_type)| format!("param{}: {}", i, param_type.to_typescript()))
            .collect::<Vec<_>>()
            .join(", ");

        let return_type = binding.return_type.to_typescript();

        let mut signature = String::new();
        
        if !binding.documentation.is_empty() {
            signature.push_str(&format!("    /**\n     * {}\n     */\n", binding.documentation));
        }

        signature.push_str(&format!("    export function {}({}): {};\n", 
                binding.method_name, params, return_type));

        signature
    }

    /// Generate a class declaration
    fn generate_class(&self, class: &ClassDescriptor) -> String {
        let mut output = String::new();
        
        if !class.documentation.is_empty() {
            output.push_str(&format!("    /**\n     * {}\n     */\n", class.documentation));
        }

        output.push_str(&format!("    export class {} {{\n", class.name));

        // Generate properties
        for property in &class.properties {
            output.push_str(&self.generate_property(property));
        }

        // Generate constructor if specified
        if let Some(_constructor) = &class.constructor {
            output.push_str("        constructor();\n");
        }

        // Generate methods
        for method_name in &class.methods {
            output.push_str(&format!("        {}(): any;\n", method_name));
        }

        output.push_str("    }\n");
        output
    }

    /// Generate a property declaration
    fn generate_property(&self, property: &PropertyDescriptor) -> String {
        let mut output = String::new();
        
        if !property.documentation.is_empty() {
            output.push_str(&format!("        /**\n         * {}\n         */\n", property.documentation));
        }

        let readonly = if property.readonly { "readonly " } else { "" };
        let prop_type = property.property_type.to_typescript();
        
        output.push_str(&format!("        {}{}: {};\n", readonly, property.name, prop_type));
        output
    }

    /// Generate a single namespace file
    pub fn generate_namespace_file(&self, namespace: &str) -> Option<String> {
        if let Some(descriptor) = self.registry.get_namespaces().get(namespace) {
            let mut output = String::new();
            
            output.push_str(&format!("// TypeScript definitions for {}\n", namespace));
            output.push_str("// Auto-generated - do not edit\n\n");
            
            output.push_str(&self.generate_namespace(namespace, descriptor));
            
            Some(output)
        } else {
            None
        }
    }

    /// Generate global declarations file
    pub fn generate_global_declarations(&self) -> String {
        let mut output = String::new();
        
        output.push_str("// Global TypeScript declarations for Longhorn Engine\n");
        output.push_str("// Auto-generated - do not edit\n\n");
        
        // Declare global Engine object
        output.push_str("declare global {\n");
        output.push_str("    const Engine: {\n");
        
        for namespace_name in self.registry.get_namespaces().keys() {
            if namespace_name.starts_with("Engine.") {
                let sub_namespace = namespace_name.strip_prefix("Engine.").unwrap();
                output.push_str(&format!("        {}: typeof {};\n", sub_namespace, namespace_name));
            }
        }
        
        output.push_str("    };\n");
        output.push_str("}\n\n");
        output.push_str("export {};\n");
        
        output
    }

    /// Generate module declarations for imports
    pub fn generate_module_declarations(&self) -> String {
        let mut output = String::new();
        
        output.push_str("// Module declarations for Longhorn Engine API\n");
        output.push_str("// Auto-generated - do not edit\n\n");
        
        for namespace_name in self.registry.get_namespaces().keys() {
            let module_name = namespace_name.replace(".", "/").to_lowercase();
            output.push_str(&format!("declare module \"@longhorn/{}\" {{\n", module_name));
            
            if let Some(descriptor) = self.registry.get_namespaces().get(namespace_name) {
                // Export classes
                for class in &descriptor.classes {
                    output.push_str(&format!("    export class {} {{\n", class.name));
                    for method_name in &class.methods {
                        output.push_str(&format!("        {}(): any;\n", method_name));
                    }
                    output.push_str("    }\n");
                }
                
                // Export functions
                for method_name in &descriptor.methods {
                    if let Some(method_binding) = self.registry.get_method(namespace_name, method_name) {
                        let params = method_binding.parameter_types
                            .iter()
                            .enumerate()
                            .map(|(i, param_type)| format!("param{}: {}", i, param_type.to_typescript()))
                            .collect::<Vec<_>>()
                            .join(", ");
                        let return_type = method_binding.return_type.to_typescript();
                        output.push_str(&format!("    export function {}({}): {};\n", 
                                method_name, params, return_type));
                    }
                }
            }
            
            output.push_str("}\n\n");
        }
        
        output
    }
}