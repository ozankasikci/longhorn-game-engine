//! Hot reload system for development
//!
//! This module provides file watching and asset reloading functionality
//! to enable rapid iteration during development.

use std::path::{Path, PathBuf};
use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};
use notify::{RecommendedWatcher, Watcher, RecursiveMode, Event as NotifyEvent, EventKind};

/// Types of assets that can be hot reloaded
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum AssetType {
    Texture,
    Model,
    Shader,
    Script,
    Audio,
    Config,
}

/// Events generated by the hot reload system
#[derive(Debug, Clone)]
pub enum HotReloadEvent {
    FileModified(PathBuf, AssetType),
    FileCreated(PathBuf, AssetType),
    FileDeleted(PathBuf, AssetType),
    DirectoryCreated(PathBuf),
    DirectoryDeleted(PathBuf),
}

/// Errors that can occur during hot reload
#[derive(Debug, thiserror::Error)]
pub enum HotReloadError {
    #[error("Hot reload is disabled")]
    Disabled,
    #[error("Failed to watch path: {0}")]
    WatchError(String),
    #[error("Failed to reload asset: {0}")]
    ReloadFailed(String),
    #[error("No handler registered for asset type: {0:?}")]
    NoHandler(AssetType),
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
}

/// Handler function for reloading assets
pub type ReloadHandler = Box<dyn Fn(&Path, AssetType) -> Result<(), HotReloadError> + Send + Sync>;

/// Hot reload manager that watches files and triggers reloads
pub struct HotReloadManager {
    enabled: bool,
    watcher: Option<RecommendedWatcher>,
    watched_paths: HashMap<PathBuf, AssetType>,
    handlers: HashMap<AssetType, ReloadHandler>,
    event_queue: Arc<Mutex<VecDeque<HotReloadEvent>>>,
    batch_window: Duration,
    last_batch_time: Instant,
}

impl HotReloadManager {
    /// Create a new hot reload manager
    pub fn new() -> Self {
        let event_queue = Arc::new(Mutex::new(VecDeque::new()));
        let queue_clone = Arc::clone(&event_queue);
        
        // Create file watcher
        let watcher = notify::recommended_watcher(move |res: Result<NotifyEvent, notify::Error>| {
            if let Ok(event) = res {
                if let Some(hot_event) = convert_notify_event(event) {
                    queue_clone.lock().unwrap().push_back(hot_event);
                }
            }
        }).ok();
        
        Self {
            enabled: true,
            watcher,
            watched_paths: HashMap::new(),
            handlers: HashMap::new(),
            event_queue,
            batch_window: Duration::from_millis(0),
            last_batch_time: Instant::now(),
        }
    }
    
    /// Check if hot reload is enabled
    pub fn is_enabled(&self) -> bool {
        self.enabled
    }
    
    /// Enable or disable hot reload
    pub fn set_enabled(&mut self, enabled: bool) {
        self.enabled = enabled;
    }
    
    /// Get list of watched paths
    pub fn get_watched_paths(&self) -> Vec<PathBuf> {
        self.watched_paths.keys().cloned().collect()
    }
    
    /// Check if a path is being watched
    pub fn is_watching(&self, path: &Path) -> bool {
        self.watched_paths.contains_key(path)
    }
    
    /// Watch a path for changes
    pub fn watch_path(&mut self, path: &Path, asset_type: AssetType) -> Result<(), HotReloadError> {
        if !self.enabled {
            return Err(HotReloadError::Disabled);
        }
        
        if let Some(ref mut watcher) = self.watcher {
            watcher.watch(path, RecursiveMode::NonRecursive)
                .map_err(|e| HotReloadError::WatchError(e.to_string()))?;
            
            self.watched_paths.insert(path.to_path_buf(), asset_type);
            Ok(())
        } else {
            Err(HotReloadError::WatchError("No watcher available".to_string()))
        }
    }
    
    /// Watch a path recursively
    pub fn watch_recursive(&mut self, path: &Path, asset_type: AssetType) -> Result<(), HotReloadError> {
        if !self.enabled {
            return Err(HotReloadError::Disabled);
        }
        
        // Watch the root path
        self.watch_path(path, asset_type)?;
        
        // Walk directory tree and watch all subdirectories
        if path.is_dir() {
            for entry in walkdir::WalkDir::new(path).into_iter().filter_map(|e| e.ok()) {
                if entry.file_type().is_dir() {
                    let sub_path = entry.path();
                    if sub_path != path {
                        self.watch_path(sub_path, asset_type)?;
                    }
                }
            }
        }
        
        Ok(())
    }
    
    /// Stop watching a path
    pub fn unwatch_path(&mut self, path: &Path) {
        if let Some(ref mut watcher) = self.watcher {
            let _ = watcher.unwatch(path);
            self.watched_paths.remove(path);
        }
    }
    
    /// Poll for file change events
    pub fn poll_events(&mut self) -> Vec<HotReloadEvent> {
        let mut events = Vec::new();
        let mut queue = self.event_queue.lock().unwrap();
        
        while let Some(event) = queue.pop_front() {
            events.push(event);
        }
        
        events
    }
    
    /// Register a handler for an asset type
    pub fn register_handler(&mut self, asset_type: AssetType, handler: ReloadHandler) {
        self.handlers.insert(asset_type, handler);
    }
    
    /// Trigger a reload for a specific asset
    pub fn trigger_reload(&self, path: &Path, asset_type: AssetType) -> Result<(), HotReloadError> {
        if !self.enabled {
            return Err(HotReloadError::Disabled);
        }
        
        if let Some(handler) = self.handlers.get(&asset_type) {
            handler(path, asset_type)
        } else {
            Err(HotReloadError::NoHandler(asset_type))
        }
    }
    
    /// Set the batch window duration
    pub fn set_batch_window(&mut self, duration: Duration) {
        self.batch_window = duration;
    }
    
    /// Get the batch window duration
    pub fn batch_window(&self) -> Duration {
        self.batch_window
    }
    
    /// Queue a reload event
    pub fn queue_reload_event(&mut self, event: HotReloadEvent) {
        self.event_queue.lock().unwrap().push_back(event);
    }
    
    /// Get batched events (waits for batch window)
    pub fn get_batched_events(&mut self) -> Vec<HotReloadEvent> {
        let now = Instant::now();
        
        if self.batch_window > Duration::ZERO && now.duration_since(self.last_batch_time) < self.batch_window {
            return Vec::new();
        }
        
        self.last_batch_time = now;
        self.poll_events()
    }
}

/// Convert notify event to hot reload event
fn convert_notify_event(event: NotifyEvent) -> Option<HotReloadEvent> {
    match event.kind {
        EventKind::Modify(_) => {
            if let Some(path) = event.paths.first() {
                // Determine asset type from extension
                let asset_type = match path.extension().and_then(|ext| ext.to_str()) {
                    Some("png") | Some("jpg") | Some("jpeg") => AssetType::Texture,
                    Some("obj") | Some("fbx") | Some("gltf") => AssetType::Model,
                    Some("wgsl") | Some("glsl") => AssetType::Shader,
                    Some("lua") | Some("js") => AssetType::Script,
                    Some("wav") | Some("mp3") | Some("ogg") => AssetType::Audio,
                    Some("toml") | Some("json") | Some("yaml") => AssetType::Config,
                    Some("txt") => AssetType::Script, // For testing
                    _ => return None,
                };
                
                Some(HotReloadEvent::FileModified(path.clone(), asset_type))
            } else {
                None
            }
        }
        EventKind::Create(_) => {
            if let Some(path) = event.paths.first() {
                if path.is_dir() {
                    Some(HotReloadEvent::DirectoryCreated(path.clone()))
                } else {
                    // Similar asset type detection as above
                    None
                }
            } else {
                None
            }
        }
        EventKind::Remove(_) => {
            if let Some(path) = event.paths.first() {
                if path.is_dir() {
                    Some(HotReloadEvent::DirectoryDeleted(path.clone()))
                } else {
                    None
                }
            } else {
                None
            }
        }
        _ => None,
    }
}

impl Default for HotReloadManager {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_asset_type_from_extension() {
        let test_files = vec![
            ("test.png", AssetType::Texture),
            ("model.obj", AssetType::Model),
            ("shader.wgsl", AssetType::Shader),
            ("script.lua", AssetType::Script),
            ("sound.wav", AssetType::Audio),
            ("config.toml", AssetType::Config),
        ];
        
        for (filename, expected_type) in test_files {
            let path = PathBuf::from(filename);
            // Test conversion logic
            assert_eq!(
                path.extension().and_then(|ext| ext.to_str()).map(|ext| match ext {
                    "png" | "jpg" | "jpeg" => AssetType::Texture,
                    "obj" | "fbx" | "gltf" => AssetType::Model,
                    "wgsl" | "glsl" => AssetType::Shader,
                    "lua" | "js" => AssetType::Script,
                    "wav" | "mp3" | "ogg" => AssetType::Audio,
                    "toml" | "json" | "yaml" => AssetType::Config,
                    _ => panic!("Unknown extension"),
                }),
                Some(expected_type)
            );
        }
    }
}